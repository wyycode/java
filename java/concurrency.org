#+TITLE:资源争用模型(泛多线程编程)
#+AUTHOR:王月阳
#+EMAIL:645583145@qq.com
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/style.css" />
#+OPTIONS:^:{}
#+KEYWORDS:Java concurrenty 多线程 资源争用 Java内存模型 AQS Java锁 MVCC
#+DESCRIPTION:讲解资源争用模型，如何解决资源争用过程中的资源安全问题。Java又是如何实现资源争用的。

 
* 线程的演进
** 从单道程序到多道程序，从多进程到多线程

    计算机最开始的时候的运行模式是从存储器（存储器大概发展过程：纸带-磁带-软盘-光盘-机械硬盘-ssd）上读取程序，然后将二进
制命令输送到cpu执行。所以初期的单道程序就是读取一个程序，cpu执行；读取一个程序，cpu执行。相对来说，cpu的运算速度要比
IO速度快很多，当任务需要执行io的时候，cpu就会等待。所以cpu呈现出来的状态就是三天打渔两天晒网的状态。这对于cpu来说是一种浪费。为了解决这个问题，前辈们
想出来这样一个方法，一次将多个程序读入到内存中，当一个程序执行到io的时候，就会切换到另一个程序执行。有可能执行的程序不需
要执行io，这样就会等待当前程序执行完成再执行下一个程序。

    随着计算机的发展，操作系统开始出现，操作系统的主要功能是通过驱动管理不同的硬件，为用户的程序提供一致的接口。进程的出
现也为管理计算机资源提供了很好的模型。进程模型是对程序执行所需要的cpu，内存，文件，设备等资源一种整合抽象。因为操作系统
是以微内核+服务的形式提供功能的。所以就要区分进程是内核进程还是用户进程。内核进程要比用户进程有更全的功能，比如操作io，
设备，文件等。所以实际上，用户程序要发生io的时候，会通过系统调用将内核进程切换到cpu，使用内核进程完成io功能。系统调用是
通过一种基础的中断方式实现，具体的不深究。

    当一个用户进程发生io后，进程会等待io完成。这个时候如果还占用cpu就会导致cpu浪费，如同单道程序一样。所以这个时候应该将
等待io的进程切换出去，将另一个进程切换到cpu中继续执行。这就是进程切换。如前文所说的，进程持有文件，设备等一系列的资源。
在进程发生切换的时候，要将当前进程的这些资源切换到内存甚至切换到硬盘中；新的进程切换进来的时候，也要把对应的资源切换进内
存和cpu中，这需要几千甚至更多的cpu运算，这其实也是对cpu资源的一种浪费。

    怎么解决资源切换带来的cpu浪费呢？我们先看一下为啥要切换进程。因为cpu执行程序到io的时候，cpu被闲置了，所以要切换到其
他进程继续使用cpu，而这个场景中是没有涉及到资源的。所以，我们真正要实现的是切换程序对cpu的控制权，而不是资源的切换。那要
怎么办呢？如果把程序的执行单位和资源拥有者分离开，每次切换的时候只切换执行单位而不切换资源，这样会不会好很多。这也就是线
程出现的原因。我们在启动一个程序的时候，为这个进程分配资源，文件，设备和cpu，但cpu真正调度的却是线程。线程相对进程来说，
不会拥有那么多的资源，在线程切换的时候，只需要切换cpu现场和很少一部分的内存数据就可以完成了。这比切换线程要减少很多cpu开
销。

    一个线程只包含线程ID，当前指令指针（PC），寄存器集合和线程堆栈。这些数据比起进程来要小很多很多。所以切换起来比进程切
换方便很多。所以一台机器可以支撑几千几万的线程并发，却只能支撑几百的进程并发。

    从上述过程可以看出，cpu执行和调度的基本单位从程序演进到进程，又演进到线程。其目的都是为了弥补io和cpu计算之间的速度差
距，实现对cpu的有效利用。

* 线程的生命周期
** 线程状态
    在jvm中的定义中，线程的状态一共有6中，分别是NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING和TERMINATED。
    - NEW：线程创建还没有开始执行的状态。在执行start方法转到RUNNABLE状态。
    - RUNNABLE：标明线程已经在JVM中执行，但可能等待操作系统为其分配资源，比如cpu，才能真正执行
    - BLOCKED：标明线程处于阻塞状态，等待获取锁
    - WAITING：标明线程处于等待状态，等待其他线程将其唤醒。BLOCKED和WAITING的区别是BLOCKED是被动阻塞，等待系统唤醒进入
      RUNNABLE状态，而WAITING是线程主动进入等待状态，由用户线程负责唤醒。jvm为了管理方便才区分了这两种状态
    - TIMED_WAITING：带超时时间的等待状态
    - TERMINATED：线程终止状态
** 线程状态之间的转换
   [NEW --start()--> RUNNABLE
   [RUNNABLE --Thread.sleep()--> WAITING]\\
   [RUNNABLE --Thread.sleep()--> WAITING]\\
   [RUNNABLE --Thread.sleep(long)--> TIMED_WAITING]\\
   [RUNNABLE --Thread.sleep(long)--> TIMED_WAITING]\\
   [RUNNABLE --Thread.sleep(long)--> TIMED_WAITING]\\
   [RUNNABLE --synchronized--> BLOCKED]\\
   [RUNNABLE --IO--> TIMED_WAITING,WAITING,BLOCKED]\\
   [TIME_WAITTING,WAITING,BLOCKED --OVERTIME,interrupt(),IOSignal,HoldLock--> RUNNABLE]\\
   [RUNNABLE --run()--> TERMINATED]

* 多线程适用场景
    - 通过在发生IO的时候切换到其他线程执行而充分利用cpu性能
    - 充分利用多核cpu性能，实现计算并行化
    - 简化业务模型，分离业务关注点

* 资源争用模型
** 资源争用模型的含义
    资源争用，顾名思义就是不同的使用者对共享的资源进行原子性使用。下面我们从日常生活中举个例子来说明一下什么是资源争用。
** 例子
    举个常见的高速路出口的例子。在这个例子中，不同的车辆就是不同的使用者，高速路出口就是共享的资源。当多辆车同时到达高速
    路出口的时候，一个出口同一个时间点只能允许一辆车通行，这可怎么办呢？现实生活中是什么样的呢，所有车辆排队依次通过出口。
    当车流量特别大的时候，排队的车辆就会很多，又怎么办，增开高速路出口，把车辆分散到不同的出口。所以在本例中，保证业务正
    常进行的两个点分别是排队和增加资源，当然是基于操作是原子的前提下。

    再举个饭店里顾客点菜厨师炒菜的例子，在这个例子中，厨师就是共享的资源，顾客就是资源争用者。那么正常生活中，是怎么保证
    菜被正常的做出来的呢？客户A点了一个菜之后，厨师开始炒菜；然后另一个人B又点了10个菜，这10个菜都由服务员通知厨师炒了。然后厨师
    就会按照服务员给的菜单的顺序一个一个炒菜。在本例中，我们默认了一个前提，就是炒菜是一个一个炒的，这是一个原子的操
    作，不可分割。不然厨师把炒这个菜的盐放到了另一个菜的锅里，就这跪了。在本例中，我们还有一个大家习以为常的点，就是厨师
    会自动的一个一个的炒菜，厨师会人工判断先炒那个菜后炒那个菜，这是不是就相当于给业务线程排了个队呢？除去排队，还有什么
    方法能减少争用呢？套路来了，增加资源啊。。。

    所以，在资源争用模型中，要么排队，要么加资源。
** 从争的角度解决问题（排队模型）
*** 排队的本质就是有序
    从上一节的例子可以看出，解决争用一个常见的方式就是让操作有序。这个模型我们可以叫它排队模型。通过各种操作的排队，实现
    操作有序，进而实现对资源的原子操作，保证资源的安全。
*** 排队的实现
    那么，排队模型怎么实现呢？就说高速路出口的例子，两车司机同时想跟在一个车后面的时候，大概是通过眼神交流，协商好，谁在
    前面谁在后面 。饭店那个例子中，做菜的先后顺序，应该是按照点菜的顺序，先来后到。这其实就是实现排队的两种方法。其一，
    就是大家协商；其二就是操作在到达争用之前，本身就是有序的。
    
    对应在Java中，协商是怎么实现的呢？线程不可能像人一样有自主思维意识，知道礼让排队。那么线程能怎么判断能不能操作资源呢？
    那么，我们可以从资源的角度来看，当资源已经被占用的时候，新来的线程是不用操作资源的，只能等待。资源没有被其他线程占用，
    也就是空闲的时候，才能被线程操作。那么线程要获取资源的操作权限的时候，可以先判断资源状态，空闲才能使用资源，使用过程
    说要将资源的状态设置为被占用，使用完成之后将资源状态设置为空闲。

    实际使用过程中，我们不可能说为每个共享的资源去设置一个状态字段，因为这与业务本身是无关的，应该被抽象出来作为一个通用
    的逻辑。怎么抽象呢，其实我们就需要一个状态字段，标明对应的资源是被占用还是空闲状态，这个字段可以以任何形式存在，没必
    要放在资源对象里面。

    前面说的是协商实现排队的方式。还有一种方式就是让自然争用者自带顺序，比如按先来后到，比如到达资源争用之前，每个争用者
    分配一个序列号，按序列号使用资源。
** 从资源的角度解决问题
   从资源的角度来解决资源争用的问题，就是提供足够多的资源，让使用者不去争。不争的还有一种方式就是资源是可被复用的，这相
   当于有无限多份资源，是足够多资源的一种特例。
*** 不共享资源 New
     不共享资源的一种实现方式是来一个争用者就创建一份新在资源给争用者使用，这样就不会跟其他争用者产生竞争关系。
*** 资源不可变 ImmutableData
    这是不共享的一种特例，相当于有无限多份资源，每个争用者可以自由使用。
** 更细的粒度
*** 共享锁与排他锁
    对资源的使用有两种情况，一是使用会修改资源，二是使用不修改资源。对于只有不修改资源的这种使用场景，就相当于资源不可变。
    但对于有修改资源操作的场景，就要排队了。也就是说修改操作是互斥的，修改操作和不修改操作是互斥的。所以因为怼资源操作的
    不同，所以资源占用对应的状态也不相同，
*** MVCC
    MVCC是一种结合了资源与排队两个方面的方法实现的争用模型，首先，资源每个版本都一个唯一的序列号，不同版本的序列号是有顺
    序的，争用者获取资源的操作之后，得到资源版本号，比如99；当要修改资源的时候，会带着序列号来操作，这样就实现了排队。而
    对于不修改资源的操作来说，可以正常获取资源，没有争用。
* Java内存模型与资源争用
  我们前面总结的，可以用一个状态位标识资源状态：可用不可用，可写不可写，可读不可读。争用者通过这个状态值实现对资源的安全
  操作。这个资源争用模型怎么套用到Java里面呢？
  *所有锁的构建，都是依赖下层工具为上层提供的原子操作* ，比如，java里面的锁，依赖了c提供的互斥量，原子操作等；而c的互斥
  量原子操作则依赖系统提供的原子操作，系统则依赖于硬件提供的原语。这种下层为上层提供的原子操作，我们可以把他们叫做原语。
  我们在构建锁的时候，都是基于原语去构建的。比如流行的分布式锁，也是基于语言提供的原语来实现的。

  在编写java代码到时候我们怎么把这套理论应用起来呢？首先我们要辨别什么是要争用的资源。然后我们分析这个资源在争用的过程中
  分别有什么样的状态，然后再决定用什么来抽象这个资源，也就是决定用什么锁。
** 分析被争用的资源
   Java的内存模型主要包含两部分,一部分是主内存，也就是所有java线程共享；另一部分是java线程的本地变量，包含局部变量和共享
   内存中的变量副本。这个模型明确的说明了，哪些是争用的资源哪些是不争用的。那么对应在java代码中，怎么区分呢？方法内的局
   部变量定义的数据，都是非争用的；其余的类的属性，对象属性，都有可能要被多线程争用。

   比如，我们常用的web编程过程中，servlet容器每接收到一个请求就会调用一个线程去处理请求。但却是调用同一个servlet对象的
   doServie方法。所以，servlet对象的属性在web编程过程中是被当作共享资源争用的，而doService方法里定义的局部变量是每个线程
   私有的。所以，servlet的属性是非线程安全的，需要一定的机制去保证线程安全。

   业务系统中，我们怎么分析被争用的资源呢？其实是一样的，关键是分析哪些资源是共享的。比如电商系统中账户的金额，比如商品
   的数量。这些都是会被不同业务线程争用的资源。下面我们具体分析一下，怎么利用资源争用模型保证数据安全的。

   *** 账户金额问题
   在一个电商系统中，账户是会存在同一个时刻有多个操作请求的，比如用户购买商品发生账户扣款的同时也在充值，比如用户同时从
   多个不同终端进行购买支付操作，比如用户连续支付多笔订单。在这一系列的业务场景中，我们怎么通过资源争用模型来保证账户金
   额的正确呢？

   首先我们分析账户金额为啥会不正确？假设账户原始金额为100.00元，业务线程A要为账户充值10元，业务线程B要从账户里扣除30元。
   业务线程A先查询到账户里有100元，然后中内存中将10元加上，此时内存中的账户是110元，然后发生了线程上下文切换，线程A被挂
   起，线程B执行，B也从数据库中读到了账户余额是100元，然后将支付的30元扣除，此时B认为账户余额应该是70元，写入到数据库中。
   线程B执行完成，用户正常支付扣款。然后线程A切换执行，又把账户的余额设置成了110元。线程A也正常执行完成，用户充值成功。
   可是，此时账户里是110元，但正常情况下，账户里应有100-30+10 = 80元。那么问题出在哪里呢？

   可以说是线程A不知道线程B已经把账户里的钱改动过了，所以认为它持有的金额是正确的。也可以说是A的操作被B打断了，所以导致
   了A的数据不正确。从资源争用的角度看怎么解决问题呢？排队！让线程A和B的操作依次进行，这样就保证数据安全了。怎么排队呢，
   用一个状态值表明账户是否被占用，占用的时候是不允许其他线程操作的。这就相当于用一个互斥量来抽象资源状态，空闲状态的资
   源才能被操作，否则线程就要等待。这是不是就是我们通常理解的锁呀。如果是单机，我们可以用java的锁来实现这个互斥量；如果
   是分布式系统，我们可以使用redis或者zookeeper提供的原子操作实现的分布式锁来抽象资源状态，进而实现对不同线程的互斥操作。

   另一种排队方案是什么呢？上面的方案是通过锁实现的排队，我们还可以认为的让所有的操作排队，比如依次只处理一个对账户的写
   操作。怎么实现呢？让所有对同一个账户的操作都放到一个队列里面，只有一个消费者线程从队列里取操作去处理账户金额，这样也
   实现了对同一个账户操作的排队。java里常用的锁，比如有synchronized关键字，JUC的Lock实现等。

   还有一种实现方式是什么呢？就是利用数据库提供的行级锁，为每行账户记录加一个版本号，业务线程操作账户金额时，必须带着之
   前查出来的版本号，那线程内部版本号和数据库存的版本号进行对比，相同的才能更新账户数据，否则就失败。这也实现了对账户操
   作的排队。这种方式其实就是不保留历史记录的MVCC方式。

   以上三种方式都通过自己的方式实现里对账户操作的排队，保证了不同业务线程对共享的账户金额的安全操作。前面提到的商品数量
   问题也可以通过这三种排队方式去实现数据安全。我们可以大胆的推理，所有的共享资源，都可以通过这三种排队方式实现安全。

   举的这个例子都是写操作，其实还有独立的读操作，比如商品数量问题，不同用户浏览商品的时候，都是对商品数量的读操作，这种
   读操作其实是不互斥的，只有发生写操作的时候，才需要互斥。也就是说资源状态中，被占用又可以分为两种状态，被写占用还是读
   占用，写占用的时候其他任何读写线程都不能操作，读占用的时候其他读线程可以操作，但写线程会被阻塞。java里的读写锁，就实
   现了对这种场景的抽象。读写锁抽象里共享资源的三个状态，实现里对共享资源操作的排队，保证里共享资源的安全。
** Java如何使用不共享内存模型解决线程安全问题
   除去上面的排队模型，还有什么方式可以解决争用呢？可以让业务线程不争用啊，大家不共享了，自然就不争用了。比如java中常见
   的SimpleDateFormat对象如果给多个线程同时使用就会出现格式化的日期不对的情况。为啥不对呢，因为SDF对象的属性被多个线程争
   用，导致了多个线程使用的时候资源状态混乱，数据错乱。从不共享的角度怎么解决问题呢？那就为每一个线程分配一个SDF对象，这
   样线程之间就不会争用一个SDF对象了，没有了争用，资源就安全了，代码执行就正常了。java中常用的实现方式有两种，一种是每次
   使用的时候new一个SDF对象出来，另一种方式是利用java提供的ThreadLocal对象。
*** ThreadLocal
    ThreadLocal在java中叫做线程封闭。什么意思呢，就是把对象封闭到使用的线程中，不给其他线程用，进而不发生争用，保证线程
    安全。怎么实现的呢，大概的模型就是利用一个map对象，key是线程，值是业务对象。每次是通过线程当key获取value的，自然不会
    重复。
** Java如果使用不可变资源模型解决线程安全问题
   不可变模型相当于是不争用的一个特例。不可变意味着可以任意复制多份到任意线程中，不会争用。可是如果要修改对象的数据怎么
   办呢？这个时候就要通过copyOnWrite实现了。copyOnWrite不会修改原对象的数据，而是会原子的复制原对象的数据， 并把新的数据
   写到新对象里面，然后返回一个新对象。java通过final关键字实现不可变对象。
*** Final关键字
*** String类

** Java如何使用排队模型解决线程安全问题
*** synchronized的用法
*** Java对象头
*** LockSupport+cas+CHL队列构成了Java锁的基础
*** AQS解读
*** 读写分离
**** ReentrantReadWriteLock
*** 写写分离
**** ConcurrentHashMap
*** CountDownLatch
*** FutureTask
*** Semaphore
 
* Java线程管理
** ThreadPoolExecutor解读
*** 参数说明
*** 核心方法解读

* 分布式系统中的资源争用
** Redis的单线程实现--排队模型
** Zookeeper一主多从--排队+读写分离
