#+TITLE:资源争用模型(泛多线程编程)
#+AUTHOR:王月阳
#+EMAIL:645583145@qq.com
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/style.css" />
#+OPTIONS:^:{}
#+KEYWORDS:Java concurrenty 多线程 资源争用 Java内存模型 AQS Java锁 MVCC
#+DESCRIPTION:讲解资源争用模型，如何解决资源争用过程中的资源安全问题。Java又是如何实现资源争用的。

 
* 线程的演进
** 从单道程序到多道程序，从多进程到多线程

    计算机最开始的时候的运行模式是从存储器（存储器大概发展过程：纸带-磁带-软盘-光盘-机械硬盘-ssd）上读取程序，然后将二进
制命令输送到cpu执行。所以初期的单道程序就是读取一个程序，cpu执行；读取一个程序，cpu执行。相对来说，cpu的运算速度要比
IO速度快很多，当任务需要执行io的时候，cpu就会等待。所以cpu呈现出来的状态就是三天打渔两天晒网的状态。这对于cpu来说是一种浪费。为了解决这个问题，前辈们
想出来这样一个方法，一次将多个程序读入到内存中，当一个程序执行到io的时候，就会切换到另一个程序执行。有可能执行的程序不需
要执行io，这样就会等待当前程序执行完成再执行下一个程序。

    随着计算机的发展，操作系统开始出现，操作系统的主要功能是通过驱动管理不同的硬件，为用户的程序提供一致的接口。进程的出
现也为管理计算机资源提供了很好的模型。进程模型是对程序执行所需要的cpu，内存，文件，设备等资源一种整合抽象。因为操作系统
是以微内核+服务的形式提供功能的。所以就要区分进程是内核进程还是用户进程。内核进程要比用户进程有更全的功能，比如操作io，
设备，文件等。所以实际上，用户程序要发生io的时候，会通过系统调用将内核进程切换到cpu，使用内核进程完成io功能。系统调用是
通过一种基础的中断方式实现，具体的不深究。

    当一个用户进程发生io后，进程会等待io完成。这个时候如果还占用cpu就会导致cpu浪费，如同单道程序一样。所以这个时候应该将
等待io的进程切换出去，将另一个进程切换到cpu中继续执行。这就是进程切换。如前文所说的，进程持有文件，设备等一系列的资源。
在进程发生切换的时候，要将当前进程的这些资源切换到内存甚至切换到硬盘中；新的进程切换进来的时候，也要把对应的资源切换进内
存和cpu中，这需要几千甚至更多的cpu运算，这其实也是对cpu资源的一种浪费。

    怎么解决资源切换带来的cpu浪费呢？我们先看一下为啥要切换进程。因为cpu执行程序到io的时候，cpu被闲置了，所以要切换到其
他进程继续使用cpu，而这个场景中是没有涉及到资源的。所以，我们真正要实现的是切换程序对cpu的控制权，而不是资源的切换。那要
怎么办呢？如果把程序的执行单位和资源拥有者分离开，每次切换的时候只切换执行单位而不切换资源，这样会不会好很多。这也就是线
程出现的原因。我们在启动一个程序的时候，为这个进程分配资源，文件，设备和cpu，但cpu真正调度的却是线程。线程相对进程来说，
不会拥有那么多的资源，在线程切换的时候，只需要切换cpu现场和很少一部分的内存数据就可以完成了。这比切换线程要减少很多cpu开
销。

    一个线程只包含线程ID，当前指令指针（PC），寄存器集合和线程堆栈。这些数据比起进程来要小很多很多。所以切换起来比进程切
换方便很多。所以一台机器可以支撑几千几万的线程并发，却只能支撑几百的进程并发。

    从上述过程可以看出，cpu执行和调度的基本单位从程序演进到进程，又演进到线程。其目的都是为了弥补io和cpu计算之间的速度差
距，实现对cpu的有效利用。

* 线程的生命周期
** 线程状态
    在jvm中的定义中，线程的状态一共有6中，分别是NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING和TERMINATED。
    - NEW：线程创建还没有开始执行的状态。在执行start方法转到RUNNABLE状态。
    - RUNNABLE：标明线程已经在JVM中执行，但可能等待操作系统为其分配资源，比如cpu，才能真正执行
    - BLOCKED：标明线程处于阻塞状态，等待获取锁
    - WAITING：标明线程处于等待状态，等待其他线程将其唤醒。BLOCKED和WAITING的区别是BLOCKED是被动阻塞，等待系统唤醒进入
      RUNNABLE状态，而WAITING是线程主动进入等待状态，由用户线程负责唤醒。jvm为了管理方便才区分了这两种状态
    - TIMED_WAITING：带超时时间的等待状态
    - TERMINATED：线程终止状态
** 线程状态之间的转换
   [NEW --start()--> RUNNABLE
   [RUNNABLE --Thread.sleep()--> WAITING]\\
   [RUNNABLE --Thread.sleep()--> WAITING]\\
   [RUNNABLE --Thread.sleep(long)--> TIMED_WAITING]\\
   [RUNNABLE --Thread.sleep(long)--> TIMED_WAITING]\\
   [RUNNABLE --Thread.sleep(long)--> TIMED_WAITING]\\
   [RUNNABLE --synchronized--> BLOCKED]\\
   [RUNNABLE --IO--> TIMED_WAITING,WAITING,BLOCKED]\\
   [TIME_WAITTING,WAITING,BLOCKED --OVERTIME,interrupt(),IOSignal,HoldLock--> RUNNABLE]\\
   [RUNNABLE --run()--> TERMINATED]

* 多线程适用场景
    - 通过在发生IO的时候切换到其他线程执行而充分利用cpu性能
    - 充分利用多核cpu性能，实现计算并行化
    - 简化业务模型，分离业务关注点

* 资源争用模型
** 资源争用模型的含义
    资源争用，顾名思义就是不同的使用者对共享的资源进行原子性使用。下面我们从日常生活中举个例子来说明一下什么是资源争用。
** 例子
    举个常见的高速路出口的例子。在这个例子中，不同的车辆就是不同的使用者，高速路出口就是共享的资源。当多辆车同时到达高速
    路出口的时候，一个出口同一个时间点只能允许一辆车通行，这可怎么办呢？现实生活中是什么样的呢，所有车辆排队依次通过出口。
    当车流量特别大的时候，排队的车辆就会很多，又怎么办，增开高速路出口，把车辆分散到不同的出口。

    再举个例子
** 从争的角度解决问题（排队模型）
*** 排队的本质就是有序
*** 排队的实现

** 从资源的角度解决问题
*** 不共享资源 CopyOnWrite
*** 资源不可变 ImmutableData

** 更细的粒度
*** 共享锁与排他锁
*** MVCC

* Java内存模型与资源争用
用一个状态位标识资源状态：可用不可用，可写不可写，可读不可读
** Java内存模型与运行时内存分布，分析被争用的资源
** Java如何使用不共享内存模型解决线程安全问题
*** copyOnWriteList
*** ThreadLocal

** Java如果使用不可变资源模型解决线程安全问题
*** Final关键字
*** String类

** Java如何使用排队模型解决线程安全问题
*** synchronized的用法
*** Java对象头
*** LockSupport+cas+CHL队列构成了Java锁的基础
*** AQS解读
*** 读写分离
**** ReentrantReadWriteLock
*** 写写分离
**** ConcurrentHashMap
*** CountDownLatch
*** FutureTask
*** Semaphore

* Java线程管理
** ThreadPoolExecutor解读
*** 参数说明
*** 核心方法解读

* 分布式系统中的资源争用
** Redis的单线程实现--排队模型
** Zookeeper一主多从--排队+读写分离
