#+TITLE:资源争用模型(泛多线程编程)
#+AUTHOR:王月阳
#+EMAIL:645583145@qq.com
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/style.css" />
#+OPTIONS:^:{}
#+KEYWORDS:Java concurrenty 多线程 资源争用 Java内存模型 AQS Java锁 MVCC
#+DESCRIPTION:讲解资源争用模型，如何解决资源争用过程中的资源安全问题。Java又是如何实现资源争用的。

 
* 线程的演进
** 从单道程序到多道程序，从多进程到多线程

    计算机最开始的时候的运行模式是从存储器（存储器大概发展过程：纸带-磁带-软盘-光盘-机械硬盘-ssd）上读取程序，然后将二进
制命令输送到cpu执行。所以初期的单道程序就是读取一个程序，cpu执行；读取一个程序，cpu执行。相对来说，cpu的运算速度要比
IO速度快很多，当任务需要执行io的时候，cpu就会等待。所以cpu呈现出来的状态就是三天打渔两天晒网的状态。这对于cpu来说是一种浪费。为了解决这个问题，前辈们
想出来这样一个方法，一次将多个程序读入到内存中，当一个程序执行到io的时候，就会切换到另一个程序执行。有可能执行的程序不需
要执行io，这样就会等待当前程序执行完成再执行下一个程序。

    随着计算机的发展，操作系统开始出现，操作系统的主要功能是通过驱动管理不同的硬件，为用户的程序提供一致的接口。进程的出
现也为管理计算机资源提供了很好的模型。进程模型是对程序执行所需要的cpu，内存，文件，设备等资源一种整合抽象。因为操作系统
是以微内核+服务的形式提供功能的。所以就要区分进程是内核进程还是用户进程。内核进程要比用户进程有更全的功能，比如操作io，
设备，文件等。所以实际上，用户程序要发生io的时候，会通过系统调用将内核进程切换到cpu，使用内核进程完成io功能。系统调用是
通过一种基础的中断方式实现，具体的不深究。

    当一个用户进程发生io后，进程会等待io完成。这个时候如果还占用cpu就会导致cpu浪费，如同单道程序一样。所以这个时候应该将
等待io的进程切换出去，将另一个进程切换到cpu中继续执行。这就是进程切换。如前文所说的，进程持有文件，设备等一系列的资源。
在进程发生切换的时候，要将当前进程的这些资源切换到内存甚至切换到硬盘中；新的进程切换进来的时候，也要把对应的资源切换进内
存和cpu中，这需要几千甚至更多的cpu运算，这其实也是对cpu资源的一种浪费。

    怎么解决资源切换带来的cpu浪费呢？我们先看一下为啥要切换进程。因为cpu执行程序到io的时候，cpu被闲置了，所以要切换到其
他进程继续使用cpu，而这个场景中是没有涉及到资源的。所以，我们真正要实现的是切换程序对cpu的控制权，而不是资源的切换。那要
怎么办呢？如果把程序的执行单位和资源拥有者分离开，每次切换的时候只切换执行单位而不切换资源，这样会不会好很多。这也就是线
程出现的原因。我们在启动一个程序的时候，为这个进程分配资源，文件，设备和cpu，但cpu真正调度的却是线程。线程相对进程来说，
不会拥有那么多的资源，在线程切换的时候，只需要切换cpu现场和很少一部分的内存数据就可以完成了。这比切换线程要减少很多cpu开
销。

    一个线程只包含线程ID，当前指令指针（PC），寄存器集合和线程堆栈。这些数据比起进程来要小很多很多。所以切换起来比进程切
换方便很多。所以一台机器可以支撑几千几万的线程并发，却只能支撑几百的进程并发。

    从上述过程可以看出，cpu执行和调度的基本单位从程序演进到进程，又演进到线程。其目的都是为了弥补io和cpu计算之间的速度差
距，实现对cpu的有效利用。

* 线程的生命周期
** 线程状态
    在jvm中的定义中，线程的状态一共有6中，分别是NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING和TERMINATED。
    - NEW：线程创建还没有开始执行的状态。在执行start方法转到RUNNABLE状态。
    - RUNNABLE：标明线程已经在JVM中执行，但可能等待操作系统为其分配资源，比如cpu，才能真正执行
    - BLOCKED：标明线程处于阻塞状态，等待获取锁
    - WAITING：标明线程处于等待状态，等待其他线程将其唤醒。BLOCKED和WAITING的区别是BLOCKED是被动阻塞，等待系统唤醒进入
      RUNNABLE状态，而WAITING是线程主动进入等待状态，由用户线程负责唤醒。jvm为了管理方便才区分了这两种状态
    - TIMED_WAITING：带超时时间的等待状态
    - TERMINATED：线程终止状态
** 线程状态之间的转换
   [NEW --start()--> RUNNABLE
   [RUNNABLE --Thread.sleep()--> WAITING]\\
   [RUNNABLE --Thread.sleep()--> WAITING]\\
   [RUNNABLE --Thread.sleep(long)--> TIMED_WAITING]\\
   [RUNNABLE --Thread.sleep(long)--> TIMED_WAITING]\\
   [RUNNABLE --Thread.sleep(long)--> TIMED_WAITING]\\
   [RUNNABLE --synchronized--> BLOCKED]\\
   [RUNNABLE --IO--> TIMED_WAITING,WAITING,BLOCKED]\\
   [TIME_WAITTING,WAITING,BLOCKED --OVERTIME,interrupt(),IOSignal,HoldLock--> RUNNABLE]\\
   [RUNNABLE --run()--> TERMINATED]

* 多线程适用场景
    - 通过在发生IO的时候切换到其他线程执行而充分利用cpu性能
    - 充分利用多核cpu性能，实现计算并行化
    - 简化业务模型，分离业务关注点

* 资源争用模型
** 资源争用模型的含义
    资源争用，顾名思义就是不同的使用者对共享的资源进行原子性使用。下面我们从日常生活中举个例子来说明一下什么是资源争用。
** 例子
    举个常见的高速路出口的例子。在这个例子中，不同的车辆就是不同的使用者，高速路出口就是共享的资源。当多辆车同时到达高速
    路出口的时候，一个出口同一个时间点只能允许一辆车通行，这可怎么办呢？现实生活中是什么样的呢，所有车辆排队依次通过出口。
    当车流量特别大的时候，排队的车辆就会很多，又怎么办，增开高速路出口，把车辆分散到不同的出口。所以在本例中，保证业务正
    常进行的两个点分别是排队和增加资源，当然是基于操作是原子的前提下。

    再举个饭店里顾客点菜厨师炒菜的例子，在这个例子中，厨师就是共享的资源，顾客就是资源争用者。那么正常生活中，是怎么保证
    菜被正常的做出来的呢？客户A点了一个菜之后，厨师开始炒菜；然后另一个人B又点了10个菜，这10个菜都由服务员通知厨师炒了。然后厨师
    就会按照服务员给的菜单的顺序一个一个炒菜。在本例中，我们默认了一个前提，就是炒菜是一个一个炒的，这是一个原子的操
    作，不可分割。不然厨师把炒这个菜的盐放到了另一个菜的锅里，就这跪了。在本例中，我们还有一个大家习以为常的点，就是厨师
    会自动的一个一个的炒菜，厨师会人工判断先炒那个菜后炒那个菜，这是不是就相当于给业务线程排了个队呢？除去排队，还有什么
    方法能减少争用呢？套路来了，增加资源啊。。。

    所以，在资源争用模型中，要么排队，要么加资源。
** 从争的角度解决问题（排队模型）
*** 排队的本质就是有序
    从上一节的例子可以看出，解决争用一个常见的方式就是让操作有序。这个模型我们可以叫它排队模型。通过各种操作的排队，实现
    操作有序，进而实现对资源的原子操作，保证资源的安全。
*** 排队的实现
    那么，排队模型怎么实现呢？就说高速路出口的例子，两车司机同时想跟在一个车后面的时候，大概是通过眼神交流，协商好，谁在
    前面谁在后面 。饭店那个例子中，做菜的先后顺序，应该是按照点菜的顺序，先来后到。这其实就是实现排队的两种方法。其一，
    就是大家协商；其二就是操作在到达争用之前，本身就是有序的。
    
    对应在Java中，协商是怎么实现的呢？线程不可能像人一样有自主思维意识，知道礼让排队。那么线程能怎么判断能不能操作资源呢？
    那么，我们可以从资源的角度来看，当资源已经被占用的时候，新来的线程是不用操作资源的，只能等待。资源没有被其他线程占用，
    也就是空闲的时候，才能被线程操作。那么线程要获取资源的操作权限的时候，可以先判断资源状态，空闲才能使用资源，使用过程
    说要将资源的状态设置为被占用，使用完成之后将资源状态设置为空闲。

    实际使用过程中，我们不可能说为每个共享的资源去设置一个状态字段，因为这与业务本身是无关的，应该被抽象出来作为一个通用
    的逻辑。怎么抽象呢，其实我们就需要一个状态字段，标明对应的资源是被占用还是空闲状态，这个字段可以以任何形式存在，没必
    要放在资源对象里面。

    前面说的是协商实现排队的方式。还有一种方式就是让自然争用者自带顺序，比如按先来后到，比如到达资源争用之前，每个争用者
    分配一个序列号，按序列号使用资源。
** 从资源的角度解决问题
   从资源的角度来解决资源争用的问题，就是提供足够多的资源，让使用者不去争。不争的还有一种方式就是资源是可被复用的，这相
   当于有无限多份资源，是足够多资源的一种特例。
*** 不共享资源 New
     不共享资源的一种实现方式是来一个争用者就创建一份新在资源给争用者使用，这样就不会跟其他争用者产生竞争关系。
*** 资源不可变 ImmutableData
    这是不共享的一种特例，相当于有无限多份资源，每个争用者可以自由使用。
** 更细的粒度
*** 共享锁与排他锁
    对资源的使用有两种情况，一是使用会修改资源，二是使用不修改资源。对于只有不修改资源的这种使用场景，就相当于资源不可变。
    但对于有修改资源操作的场景，就要排队了。也就是说修改操作是互斥的，修改操作和不修改操作是互斥的。所以因为怼资源操作的
    不同，所以资源占用对应的状态也不相同，
*** MVCC
    MVCC是一种结合了资源与排队两个方面的方法实现的争用模型，首先，资源每个版本都一个唯一的序列号，不同版本的序列号是有顺
    序的，争用者获取资源的操作之后，得到资源版本号，比如99；当要修改资源的时候，会带着序列号来操作，这样就实现了排队。而
    对于不修改资源的操作来说，可以正常获取资源，没有争用。
* Java内存模型与资源争用
  我们前面总结的，可以用一个状态位标识资源状态：可用不可用，可写不可写，可读不可读。争用者通过这个状态值实现对资源的安全
  操作。这个资源争用模型怎么套用到Java里面呢？
  *所有锁的构建，都是依赖下层工具为上层提供的原子操作* ，比如，java里面的锁，依赖了c提供的互斥量，原子操作等；而c的互斥
  量原子操作则依赖系统提供的原子操作，系统则依赖于硬件提供的原语。这种下层为上层提供的原子操作，我们可以把他们叫做原语。
  我们在构建锁的时候，都是基于原语去构建的。比如流行的分布式锁，也是基于语言提供的原语来实现的。

  在编写java代码到时候我们怎么把这套理论应用起来呢？首先我们要辨别什么是要争用的资源。然后我们分析这个资源在争用的过程中
  分别有什么样的状态，然后再决定用什么来抽象这个资源，也就是决定用什么锁。
** Java内存模型与运行时内存分布，分析被争用的资源
   Java的内存模型主要包含两部分,一部分是主内存，也就是所有java线程共享；另一部分是java线程的本地变量，包含局部变量和共享
   内存中的变量副本。这个模型明确的说明了，哪些是争用的资源哪些是不争用的。那么对应在java代码中，怎么区分呢？方法内的局
   部变量定义的数据，都是非争用的；其余的类的属性，对象属性，或者传入的参数，都有可能要被多线程争用。

   比如，我们常规的web编程过程中，servlet容器每接收到一个请求就会调用一个线程去处理请求。但却是调用同一个servlet对象的
   doServie方法。所以，servlet对象的属性在web编程过程中是被当作共享资源争用的，而doService方法里定义的局部变量是每个线程
   私有的。所以，servlet的属性是非线程安全的，需要一定的机制去保证线程安全。
** Java如何使用不共享内存模型解决线程安全问题
*** copyOnWriteList
*** ThreadLocal

** Java如果使用不可变资源模型解决线程安全问题
*** Final关键字
*** String类

** Java如何使用排队模型解决线程安全问题
*** synchronized的用法
*** Java对象头
*** LockSupport+cas+CHL队列构成了Java锁的基础
*** AQS解读
*** 读写分离
**** ReentrantReadWriteLock
*** 写写分离
**** ConcurrentHashMap
*** CountDownLatch
*** FutureTask
*** Semaphore
 
* Java线程管理
** ThreadPoolExecutor解读
*** 参数说明
*** 核心方法解读

* 分布式系统中的资源争用
** Redis的单线程实现--排队模型
** Zookeeper一主多从--排队+读写分离
